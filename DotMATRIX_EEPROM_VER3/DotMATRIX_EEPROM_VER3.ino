/*
 * 포함된 라이브러리
 - 파일에 포함된 MaxMatrix.zip파일을 아래의 경로를 통해 추가
 스케치 > 라이브러리 포함하기 > .ZIP라이브러리 추가 > 열기
 */

#include <EEPROM.h> //EEPROM 라이브러리
#include <MaxMatrix.h>
#include <SoftwareSerial.h>
#include <avr/pgmspace.h>


PROGMEM const unsigned char CH[] = {
  3, 8, B00000000, B00000000, B00000000, B00000000, B00000000, // space
  1, 8, B01011111, B00000000, B00000000, B00000000, B00000000, // !
  3, 8, B00000011, B00000000, B00000011, B00000000, B00000000, // "
  5, 8, B00010100, B00111110, B00010100, B00111110, B00010100, // #
  4, 8, B00100100, B01101010, B00101011, B00010010, B00000000, // $
  5, 8, B01100011, B00010011, B00001000, B01100100, B01100011, // %
  5, 8, B00110110, B01001001, B01010110, B00100000, B01010000, // &
  1, 8, B00000011, B00000000, B00000000, B00000000, B00000000, // '
  3, 8, B00011100, B00100010, B01000001, B00000000, B00000000, // (
  3, 8, B01000001, B00100010, B00011100, B00000000, B00000000, // )
  5, 8, B00101000, B00011000, B00001110, B00011000, B00101000, // *
  5, 8, B00001000, B00001000, B00111110, B00001000, B00001000, // +
  2, 8, B10110000, B01110000, B00000000, B00000000, B00000000, // ,
  4, 8, B00001000, B00001000, B00001000, B00001000, B00000000, // -
  2, 8, B01100000, B01100000, B00000000, B00000000, B00000000, // .
  4, 8, B01100000, B00011000, B00000110, B00000001, B00000000, // /
  4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // 0
  3, 8, B01000010, B01111111, B01000000, B00000000, B00000000, // 1
  4, 8, B01100010, B01010001, B01001001, B01000110, B00000000, // 2
  4, 8, B00100010, B01000001, B01001001, B00110110, B00000000, // 3
  4, 8, B00011000, B00010100, B00010010, B01111111, B00000000, // 4
  4, 8, B00100111, B01000101, B01000101, B00111001, B00000000, // 5
  4, 8, B00111110, B01001001, B01001001, B00110000, B00000000, // 6
  4, 8, B01100001, B00010001, B00001001, B00000111, B00000000, // 7
  4, 8, B00110110, B01001001, B01001001, B00110110, B00000000, // 8
  4, 8, B00000110, B01001001, B01001001, B00111110, B00000000, // 9
  2, 8, B01010000, B00000000, B00000000, B00000000, B00000000, // :
  2, 8, B10000000, B01010000, B00000000, B00000000, B00000000, // ;
  3, 8, B00010000, B00101000, B01000100, B00000000, B00000000, // <
  3, 8, B00010100, B00010100, B00010100, B00000000, B00000000, // =
  3, 8, B01000100, B00101000, B00010000, B00000000, B00000000, // >
  4, 8, B00000010, B01011001, B00001001, B00000110, B00000000, // ?
  5, 8, B00111110, B01001001, B01010101, B01011101, B00001110, // @
  4, 8, B01111110, B00010001, B00010001, B01111110, B00000000, // A
  4, 8, B01111111, B01001001, B01001001, B00110110, B00000000, // B
  4, 8, B00111110, B01000001, B01000001, B00100010, B00000000, // C
  4, 8, B01111111, B01000001, B01000001, B00111110, B00000000, // D
  4, 8, B01111111, B01001001, B01001001, B01000001, B00000000, // E
  4, 8, B01111111, B00001001, B00001001, B00000001, B00000000, // F
  4, 8, B00111110, B01000001, B01001001, B01111010, B00000000, // G
  4, 8, B01111111, B00001000, B00001000, B01111111, B00000000, // H
  3, 8, B01000001, B01111111, B01000001, B00000000, B00000000, // I
  4, 8, B00110000, B01000000, B01000001, B00111111, B00000000, // J
  4, 8, B01111111, B00001000, B00010100, B01100011, B00000000, // K
  4, 8, B01111111, B01000000, B01000000, B01000000, B00000000, // L
  5, 8, B01111111, B00000010, B00001100, B00000010, B01111111, // M
  5, 8, B01111111, B00000100, B00001000, B00010000, B01111111, // N
  4, 8, B00111110, B01000001, B01000001, B00111110, B00000000, // O
  4, 8, B01111111, B00001001, B00001001, B00000110, B00000000, // P
  4, 8, B00111110, B01000001, B01000001, B10111110, B00000000, // Q
  4, 8, B01111111, B00001001, B00001001, B01110110, B00000000, // R
  4, 8, B01000110, B01001001, B01001001, B00110010, B00000000, // S
  5, 8, B00000001, B00000001, B01111111, B00000001, B00000001, // T
  4, 8, B00111111, B01000000, B01000000, B00111111, B00000000, // U
  5, 8, B00001111, B00110000, B01000000, B00110000, B00001111, // V
  5, 8, B00111111, B01000000, B00111000, B01000000, B00111111, // W
  5, 8, B01100011, B00010100, B00001000, B00010100, B01100011, // X
  5, 8, B00000111, B00001000, B01110000, B00001000, B00000111, // Y
  4, 8, B01100001, B01010001, B01001001, B01000111, B00000000, // Z
  2, 8, B01111111, B01000001, B00000000, B00000000, B00000000, // [
  4, 8, B00000001, B00000110, B00011000, B01100000, B00000000, // \ backslash
  2, 8, B01000001, B01111111, B00000000, B00000000, B00000000, // ]
  3, 8, B00000010, B00000001, B00000010, B00000000, B00000000, // hat
  4, 8, B01000000, B01000000, B01000000, B01000000, B00000000, // _
  2, 8, B00000001, B00000010, B00000000, B00000000, B00000000, // `
  4, 8, B00100000, B01010100, B01010100, B01111000, B00000000, // a
  4, 8, B01111111, B01000100, B01000100, B00111000, B00000000, // b
  4, 8, B00111000, B01000100, B01000100, B00101000, B00000000, // c
  4, 8, B00111000, B01000100, B01000100, B01111111, B00000000, // d
  4, 8, B00111000, B01010100, B01010100, B00011000, B00000000, // e
  3, 8, B00000100, B01111110, B00000101, B00000000, B00000000, // f
  4, 8, B10011000, B10100100, B10100100, B01111000, B00000000, // g
  4, 8, B01111111, B00000100, B00000100, B01111000, B00000000, // h
  3, 8, B01000100, B01111101, B01000000, B00000000, B00000000, // i
  4, 8, B01000000, B10000000, B10000100, B01111101, B00000000, // j
  4, 8, B01111111, B00010000, B00101000, B01000100, B00000000, // k
  3, 8, B01000001, B01111111, B01000000, B00000000, B00000000, // l
  5, 8, B01111100, B00000100, B01111100, B00000100, B01111000, // m
  4, 8, B01111100, B00000100, B00000100, B01111000, B00000000, // n
  4, 8, B00111000, B01000100, B01000100, B00111000, B00000000, // o
  4, 8, B11111100, B00100100, B00100100, B00011000, B00000000, // p
  4, 8, B00011000, B00100100, B00100100, B11111100, B00000000, // q
  4, 8, B01111100, B00001000, B00000100, B00000100, B00000000, // r
  4, 8, B01001000, B01010100, B01010100, B00100100, B00000000, // s
  3, 8, B00000100, B00111111, B01000100, B00000000, B00000000, // t
  4, 8, B00111100, B01000000, B01000000, B01111100, B00000000, // u
  5, 8, B00011100, B00100000, B01000000, B00100000, B00011100, // v
  5, 8, B00111100, B01000000, B00111100, B01000000, B00111100, // w
  5, 8, B01000100, B00101000, B00010000, B00101000, B01000100, // x
  4, 8, B10011100, B10100000, B10100000, B01111100, B00000000, // y
  3, 8, B01100100, B01010100, B01001100, B00000000, B00000000, // z
  3, 8, B00001000, B00110110, B01000001, B00000000, B00000000, // {
  1, 8, B01111111, B00000000, B00000000, B00000000, B00000000, // |
  3, 8, B01000001, B00110110, B00001000, B00000000, B00000000, // }
  4, 8, B00001000, B00000100, B00001000, B00000100, B00000000, // ~ 
};

void write_String(int addrs, String source) //문자열 WRITING
{
  int stringSize = source.length(); //문자열 길이
  for(int i=0;i<100;i++)
  {
    EEPROM.write(addrs+i, source[i]); //문자열을 롬에 저장
  }
  EEPROM.write(addrs + stringSize,'\0'); //문자열 맨 뒤에 공백 저장 (끝을 구분)
}

String read_String(int addrs)
{
  char source[100]; //Max 100 Bytes
  int leng=0; 
  unsigned char _char; //임시 CHAR
  while(_char != '\0' && leng < 100) //공백이 오고(끝) Max(100)에 도달하였을때 반복문 탈출
  {
    _char = EEPROM.read(addrs + leng); //임시 CHAR에 롬에 저장된 전체 배열 중에서 [addrs]로부터 [leng]번 떨어진 문자 저장
    source[leng] = _char; //그것을 다시 리턴할 문자열에 저장
    leng++;
  }
  source[leng]='\0';  //마지막에 공백문자 추가(없을 경우 문자가 서로 이어져서 출력됨
  return String(source);
}

bool butState(){
  int state = digitalRead(10);
  Serial.println(state);
  return state;
}

/*
 아두이노 MAX7219포트 설정 (GND / VCC는 5V)
 포트는 회로 구성의 여건에 따라 변경 가능합니다.
 */
int dIn = 7;                                     // DIN 포트
int clk = 3;                                     // CLK 포트
int cs = 4;                                      // CS 포트
int maxInUse = 4;                                // 도트매트릭스 사용 개수

int butVal, butPast = 2, matrixState;
/*
 * 도트매트릭스 초기 출력 설정 (부분 수정 가능)
   수정 가능 사항 : scrollSpeed, text, brightness
 */
MaxMatrix m(dIn, cs, clk, maxInUse);
SoftwareSerial Bluetooth(8, 9);                   // 블루투스 연결 (RX - 9, TX - 8)
byte buffer[10];
char incomebyte;
int scrollSpeed;                            // 처음 시작할때 전광판 속도
String lastWords = read_String(0);
char text[100] = "";             
int brightness;
int count = 0;
char indicator; // 변수이름 수정하지 말것


void setup() {
  m.init();
  m.setIntensity(brightness);                      // 처음 시작할때 밝기
  Bluetooth.begin(9600);                           // 블루투스 모듈 속도 (블루투스 모델에 따라 변경 가능)
  Serial.begin(9600); 
  for(int i= 0; i < 100; i++){
    text[i] = lastWords[i];
  }
  m.setIntensity(EEPROM.read(103)); //기존에 저장된 밝기 불러옴
  scrollSpeed = EEPROM.read(102); //기존에 저장된 스크롤 속도 불러옴
}


void loop() {
  butVal = butState();
  if(butVal != butPast){
    if(butVal == 1)
      matrixState = 0;
    else
      matrixState = 1;
  }
  butPast = butVal;

  if(matrixState == 1)
    printStringWithShift(text, scrollSpeed);          // 텍스트 출력// 텍스트 출력
  else
    m.clear();
  
    
  if (Bluetooth.available()) {                      // 시리얼 포트에서 데이터값이 오는지 확인
    indicator = Bluetooth.read();                   // 블루투스 시리얼 포트 읽기 시작
    
   Serial.println(indicator);
    /*
       보내기 버튼 클릭시 전에 있던 텍스트 지우기
     - 앱인벤터에서 보내기 버튼 클릭시 '1' 보내기
     */
    if (indicator == '1') {
      
      for (int i = 0; i < 100; i++) {
        text[i] = 0;
        m.clear();
      }
      write_String(0, text); //초기화된 문자 저장 (똑같이 초기화)
      
      // 핸드폰에서 오는 모든 데이터값(문자열)을 읽고 텍스트 배열에 넣기
      while (Bluetooth.available()) {
        incomebyte = Bluetooth.read();
        text[count] = incomebyte;
        count++;
      }
      count = 0;
      write_String(0, text); //들여온 문자 저장
      Bluetooth.write('1');
    }
    
      /*
     스크롤바로 전광판 속도 조절
     -앱인벤터에서 텍스트 '2' 보내면 섬네일 위치에 따라 값조정
     */ 
    else if (indicator == '2') {
      String sS = Bluetooth.readString();
      scrollSpeed = 100 - sS.toInt();                // (100~150) 변경가능, 밀리세컨드, 값이 낮을수록 속도가 빨라짐
      EEPROM.write(102, scrollSpeed); //스크롤 속도 저장
      Bluetooth.write('1');
    }

      /*
     스크롤바로 전광판 밝기 조절
     -앱인벤터에서 텍스트 '3' 보내면 섬네일 위치에 따라 값조정
     */

    else if (indicator == '3') {
      String sB = Bluetooth.readString();
      brightness = sB.toInt();
      EEPROM.write(103, brightness); //밝기 저장
      m.setIntensity(brightness);
      Bluetooth.write('1');
    }

    else if (indicator == '4') {
      matrixState = 0;
      Bluetooth.write('1');
    }

    else if (indicator == '5') {
      matrixState = 1;
      Bluetooth.write('1');
    }
  }
}


/*
 문자 배열을 사용하여 스크롤 텍스트를 정의하고 반복 부분에서 printStringWithShift함수는
 두번째 인수와 밀리 초 단위로 정의 된 스크롤 속도로 LED에 텍스트를 출력합니다.

 printStringWithShift 함수는 입력받은 텍스트 문자열에서 추출한 문자를
 LED에 스크롤문자로 출력하는 것입니다

 for문과 반복문을 사용하여 문자가 다음에 출력될 위치를 계산합니다.
 */
void printCharWithShift(char c, int shift_speed) {
  if (c < 32) return;
  c -= 32;
  memcpy_P(buffer, CH + 7 * c, 7);
  m.writeSprite(32, 0, buffer);
  m.setColumn(32 + buffer[0], 0);
  for (int i = 0; i < buffer[0] + 1; i++)
  {
    delay(shift_speed);
    m.shiftLeft(false, false);
  }
}
void printStringWithShift(char* s, int shift_speed) {
  while (*s != 0) {
    printCharWithShift(*s, shift_speed);
    s++;
  }
}
void printString(char* s)
{
  int col = 0;
  while (*s != 0)
  {
    if (*s < 32) continue;
    char c = *s - 32;
    memcpy_P(buffer, CH + 7 * c, 7);
    m.writeSprite(col, 0, buffer);
    m.setColumn(col + buffer[0], 0);
    col += buffer[0] + 1;
    s++;
  }
}
